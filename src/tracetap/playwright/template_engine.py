"""
TypeScript code generation from templates.

Generates clean, formatted Playwright test files from test data.
"""

import json
from typing import List, Dict, Any, Optional
from datetime import datetime

from .test_converter import PlaywrightTest, PlaywrightTestFile
from .fixture_generator import FixtureDefinition
from .script_analyzer import TestAssertion


class TemplateEngine:
    """Generate TypeScript code from templates."""

    def __init__(self, indent: str = '  '):
        """
        Initialize template engine.

        Args:
            indent: Indentation string (default: 2 spaces)
        """
        self.indent = indent

    def render_test_file(
        self,
        test_file: PlaywrightTestFile,
        fixtures: List[FixtureDefinition],
        fixture_extension: str,
        include_comments: bool = True
    ) -> str:
        """
        Generate complete Playwright test file.

        Args:
            test_file: PlaywrightTestFile with all tests
            fixtures: List of fixture definitions
            fixture_extension: Complete fixture extension code
            include_comments: Whether to include helpful comments

        Returns:
            Complete TypeScript test file content
        """
        parts = []

        # Header comment
        if include_comments:
            parts.append(self._render_header_comment(test_file.name))

        # Imports
        parts.append(self._render_imports(bool(fixtures)))

        # Fixture extension
        if fixture_extension:
            parts.append(fixture_extension)
            parts.append("")  # Blank line

        # Main test.describe block
        parts.append(f"test.describe('{test_file.name}', () => {{")

        # Group tests by folder
        if test_file.describe_blocks:
            for folder_key, tests in test_file.describe_blocks.items():
                if folder_key == '__root__':
                    # Tests without folder
                    for test in tests:
                        parts.append(self._render_test(test, indent_level=1))
                else:
                    # Tests in folder
                    folder_names = folder_key.split(' > ')
                    parts.append(self._render_nested_describes(folder_names, tests, indent_level=1))
        else:
            # No folder structure, render all tests directly
            for test in test_file.tests:
                parts.append(self._render_test(test, indent_level=1))

        parts.append("});")

        return '\n'.join(parts)

    def _render_header_comment(self, collection_name: str) -> str:
        """Render header comment."""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        return f"""/**
 * Playwright API Tests
 * Generated from Postman Collection: {collection_name}
 * Generated on: {timestamp}
 *
 * This file was automatically generated by TraceTap.
 * You may need to adjust authentication and environment variables.
 */
"""

    def _render_imports(self, has_fixtures: bool) -> str:
        """Render import statements."""
        if has_fixtures:
            return "import { test as base, expect } from '@playwright/test';"
        else:
            return "import { test, expect } from '@playwright/test';"

    def _render_nested_describes(
        self,
        folder_names: List[str],
        tests: List[PlaywrightTest],
        indent_level: int
    ) -> str:
        """Render nested test.describe blocks for folder structure."""
        lines = []
        indent = self.indent * indent_level

        # Open describe blocks
        for i, folder_name in enumerate(folder_names):
            current_indent = self.indent * (indent_level + i)
            lines.append(f"{current_indent}test.describe('{folder_name}', () => {{")

        # Render tests
        test_indent_level = indent_level + len(folder_names)
        for test in tests:
            lines.append(self._render_test(test, indent_level=test_indent_level))

        # Close describe blocks
        for i in range(len(folder_names) - 1, -1, -1):
            current_indent = self.indent * (indent_level + i)
            lines.append(f"{current_indent}}});")
            if i > 0:
                lines.append("")  # Blank line between nested describes

        return '\n'.join(lines)

    def _render_test(self, test: PlaywrightTest, indent_level: int) -> str:
        """Render a single test case."""
        lines = []
        indent = self.indent * indent_level

        # Test description comment
        if test.description:
            lines.append(f"{indent}// {test.description}")

        # Determine fixture parameters
        fixtures_used = self._detect_fixtures_in_test(test)
        fixture_params = ['request'] + fixtures_used

        # Test function signature
        lines.append(f"{indent}test('{test.name}', async ({{ {', '.join(fixture_params)} }}) => {{")

        # Test body
        body_indent = self.indent * (indent_level + 1)

        # Setup code
        if test.setup_code:
            for setup_line in test.setup_code:
                lines.append(f"{body_indent}{setup_line}")
            lines.append("")  # Blank line after setup

        # Request code
        request_code = self._render_request(test)
        lines.append(f"{body_indent}{request_code}")
        lines.append("")  # Blank line after request

        # Assertions
        if test.assertions:
            for assertion in test.assertions:
                if isinstance(assertion, str):
                    lines.append(f"{body_indent}{assertion}")
                elif isinstance(assertion, TestAssertion):
                    if assertion.description and assertion.description != test.name:
                        lines.append(f"{body_indent}// {assertion.description}")
                    lines.append(f"{body_indent}{assertion.code}")
            lines.append("")  # Blank line after assertions

        # Variable extractions
        if test.variable_extractions:
            lines.append(f"{body_indent}// Extract variables for use in later tests")
            for extraction in test.variable_extractions:
                lines.append(f"{body_indent}// {extraction.get('description', '')}")
                var_name = extraction.get('variable_name', '')
                json_path = extraction.get('json_path', '')
                lines.append(f"{body_indent}const {var_name} = {json_path};")

        # Close test function
        lines.append(f"{indent}}});")
        lines.append("")  # Blank line after test

        return '\n'.join(lines)

    def _render_request(self, test: PlaywrightTest) -> str:
        """Render the HTTP request code."""
        method = test.method.lower()

        # Build URL - wrap in template literal if it contains ${}
        url = test.url
        if '${' in url:
            url_str = f"`{url}`"
        else:
            url_str = f"'{url}'"

        # Build options object
        options = []

        # Headers
        if test.headers:
            headers_obj = self._dict_to_ts_object(test.headers, indent_level=0)
            options.append(f"headers: {headers_obj}")

        # Body
        if test.body is not None:
            body_obj = self._value_to_ts(test.body, indent_level=0)
            options.append(f"data: {body_obj}")

        # Build request call
        if options:
            options_str = "{ " + ", ".join(options) + " }"
            return f"const response = await request.{method}({url_str}, {options_str});"
        else:
            return f"const response = await request.{method}({url_str});"

    def _detect_fixtures_in_test(self, test: PlaywrightTest) -> List[str]:
        """Detect which fixtures are used in a test."""
        fixtures = []
        test_str = json.dumps({
            'url': test.url,
            'headers': test.headers,
            'body': test.body
        })

        # Check for common fixtures
        if '${baseUrl}' in test_str:
            fixtures.append('baseUrl')
        if '${authToken}' in test_str or 'Bearer ${authToken}' in test_str:
            fixtures.append('authToken')

        # Check for other variable references
        import re
        var_matches = re.findall(r'\$\{([a-zA-Z_][a-zA-Z0-9_]*)\}', test_str)
        for var in var_matches:
            if var not in ['baseUrl', 'authToken'] and var not in fixtures:
                fixtures.append(var)

        return fixtures

    def _dict_to_ts_object(self, obj: Dict[str, Any], indent_level: int) -> str:
        """Convert Python dict to TypeScript object literal."""
        if not obj:
            return "{}"

        # For simple objects, inline
        if len(obj) <= 2 and all(isinstance(v, (str, int, bool, type(None))) for v in obj.values()):
            items = [f"'{k}': {self._value_to_ts(v)}" for k, v in obj.items()]
            return "{ " + ", ".join(items) + " }"

        # For complex objects, multi-line
        indent = self.indent * indent_level
        next_indent = self.indent * (indent_level + 1)

        lines = ["{"]
        for key, value in obj.items():
            value_str = self._value_to_ts(value, indent_level + 1)
            lines.append(f"{next_indent}'{key}': {value_str},")
        lines.append(f"{indent}}}")

        return '\n'.join(lines)

    def _value_to_ts(self, value: Any, indent_level: int = 0) -> str:
        """Convert Python value to TypeScript literal."""
        if value is None:
            return "null"
        elif isinstance(value, bool):
            return "true" if value else "false"
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, str):
            # Check if it contains template variable
            if '${' in value:
                return f"`{value}`"
            else:
                # Escape quotes
                escaped = value.replace("'", "\\'")
                return f"'{escaped}'"
        elif isinstance(value, dict):
            return self._dict_to_ts_object(value, indent_level)
        elif isinstance(value, list):
            items = [self._value_to_ts(item, indent_level) for item in value]
            return "[" + ", ".join(items) + "]"
        else:
            return str(value)

    def format_typescript(self, code: str) -> str:
        """
        Basic TypeScript code formatting.

        Args:
            code: TypeScript code to format

        Returns:
            Formatted code
        """
        # Remove excessive blank lines
        import re
        code = re.sub(r'\n{3,}', '\n\n', code)

        # Ensure file ends with newline
        if not code.endswith('\n'):
            code += '\n'

        return code
